<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>飛機大戰</title>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at top, #0f172a 0%, #020617 55%, #01040c 100%);
            font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
            color: #e2e8f0;
            padding: 24px 16px;
        }

        .wrapper {
            width: min(920px, 100%);
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
            align-items: center;
        }

        .hud {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            flex-wrap: wrap;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.85), rgba(30, 41, 59, 0.9));
            border: 1px solid rgba(148, 163, 184, 0.25);
            border-radius: 14px;
            padding: 14px 20px;
            box-shadow: 0 18px 36px -20px rgba(15, 118, 110, 0.55);
            backdrop-filter: blur(6px);
        }

        .hud h1 {
            font-size: 1.4rem;
            letter-spacing: 0.12em;
        }

        .stats {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.92rem;
            flex-wrap: wrap;
        }

        .stats span {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            color: #cbd5f5;
        }

        .stats strong {
            color: #38bdf8;
            font-weight: 600;
        }

        .actions {
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.5rem 1.3rem;
            border-radius: 8px;
            border: 1px solid rgba(56, 189, 248, 0.45);
            background: linear-gradient(135deg, #38bdf8, #0ea5e9);
            color: #0b1120;
            font-weight: 600;
            letter-spacing: 0.08em;
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }

        button:hover,
        button:focus-visible {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px -12px rgba(14, 165, 233, 0.6);
            outline: none;
        }

        canvas {
            width: min(800px, 100%);
            height: auto;
            background: radial-gradient(circle at 25% 15%, rgba(59, 130, 246, 0.24), transparent 45%),
                        radial-gradient(circle at 75% 25%, rgba(99, 102, 241, 0.16), transparent 60%),
                        #020617;
            border: 2px solid rgba(30, 41, 59, 0.8);
            border-radius: 16px;
            box-shadow: 0 30px 55px -35px rgba(56, 189, 248, 0.8);
        }

        .controls {
            font-size: 0.85rem;
            letter-spacing: 0.05em;
            color: #94a3b8;
            text-align: center;
        }

        .status {
            min-height: 1.2rem;
            font-size: 0.9rem;
            letter-spacing: 0.08em;
            color: #f8fafc;
            text-align: center;
        }

        .status span {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.22), rgba(14, 165, 233, 0.28));
            padding: 0.25rem 0.9rem;
            border-radius: 999px;
            display: inline-block;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 23, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.25s ease;
        }

        .overlay[hidden] {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-panel {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(30, 41, 59, 0.92));
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 16px;
            padding: 28px 32px;
            width: min(360px, 90vw);
            text-align: center;
            box-shadow: 0 20px 60px -25px rgba(56, 189, 248, 0.75);
        }

        .overlay-panel h2 {
            font-size: 1.4rem;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            color: #38bdf8;
        }

        .overlay-panel p {
            color: #e2e8f0;
            margin-bottom: 1.4rem;
            line-height: 1.6;
        }

        .upgrade-overlay {
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 23, 0.78);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            transition: opacity 0.25s ease;
        }

        .upgrade-overlay[hidden] {
            opacity: 0;
            pointer-events: none;
        }

        .upgrade-panel {
            width: min(420px, 92vw);
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(30, 41, 59, 0.9));
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 16px;
            padding: 24px 28px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 28px 60px -28px rgba(56, 189, 248, 0.65);
        }

        .upgrade-panel h2 {
            font-size: 1.3rem;
            letter-spacing: 0.08em;
            color: #38bdf8;
        }

        .upgrade-panel p {
            font-size: 0.92rem;
            color: #cbd5f5;
            line-height: 1.55;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .upgrade-card {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 14px 16px;
            background: linear-gradient(140deg, rgba(56, 189, 248, 0.18), rgba(59, 130, 246, 0.12));
            border: 1px solid rgba(148, 163, 184, 0.32);
            border-radius: 12px;
            transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
            text-align: left;
            color: #e2e8f0;
        }

        .upgrade-card:hover,
        .upgrade-card:focus-visible {
            transform: translateY(-2px);
            border-color: rgba(56, 189, 248, 0.55);
            background: linear-gradient(140deg, rgba(56, 189, 248, 0.26), rgba(59, 130, 246, 0.2));
            outline: none;
        }

        .upgrade-card:disabled {
            opacity: 0.45;
            transform: none;
            cursor: not-allowed;
            border-color: rgba(148, 163, 184, 0.2);
            background: linear-gradient(140deg, rgba(71, 85, 105, 0.2), rgba(30, 41, 59, 0.3));
        }

        .upgrade-card .title {
            font-size: 1rem;
            font-weight: 600;
            color: #38bdf8;
        }

        .upgrade-card .meta {
            font-size: 0.78rem;
            letter-spacing: 0.12em;
            color: #94a3b8;
            text-transform: uppercase;
        }

        .upgrade-card .desc {
            font-size: 0.88rem;
            color: #cbd5f5;
            line-height: 1.45;
        }

        .upgrade-actions {
            display: flex;
            justify-content: flex-end;
        }

        .upgrade-actions button {
            background: linear-gradient(135deg, #475569, #1e293b);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.4);
        }

        .upgrade-actions button:hover,
        .upgrade-actions button:focus-visible {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px -12px rgba(14, 165, 233, 0.4);
            outline: none;
        }

        @media (max-width: 640px) {
            .hud {
                flex-direction: column;
                align-items: flex-start;
            }

            .actions {
                width: 100%;
            }

            button {
                flex: 1 1 auto;
            }
        }
    </style>
</head>
<body>
    <div class="wrapper">
        <header class="hud" aria-live="polite">
            <h1>飛機大戰</h1>
            <div class="stats">
                <span>分數 <strong id="scoreDisplay">0</strong></span>
                <span>生命 <strong id="livesDisplay">3</strong></span>
                <span>波次 <strong id="waveDisplay">1</strong></span>
                <span>無人機 <strong id="droneLevelDisplay">Lv0</strong></span>
            </div>
            <div class="actions">
                <button type="button" id="startButton">開始遊戲</button>
                <button type="button" id="pauseButton" aria-pressed="false">暫停</button>
            </div>
        </header>
        <canvas id="gameCanvas" width="800" height="600" aria-label="飛機大戰遊戲畫布" role="img"></canvas>
        <p class="controls">方向鍵 / WASD 移動，空白鍵射擊。按「暫停」可暫停遊戲。</p>
        <p class="status" id="statusMessage" aria-live="assertive"></p>
    </div>

    <div class="overlay" id="messageOverlay" hidden role="dialog" aria-modal="true">
        <div class="overlay-panel">
            <h2 id="overlayTitle">遊戲結束</h2>
            <p id="overlayText"></p>
            <button type="button" id="overlayButton">重新挑戰</button>
        </div>
    </div>

    <div class="upgrade-overlay" id="upgradeOverlay" hidden role="dialog" aria-modal="true" aria-labelledby="upgradeTitle">
        <div class="upgrade-panel">
            <h2 id="upgradeTitle">選擇升級</h2>
            <p id="upgradeSubtitle">選擇一項能力強化。</p>
            <div class="upgrade-options" id="upgradeOptions"></div>
            <div class="upgrade-actions">
                <button type="button" id="skipUpgradeButton">下次再說</button>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const scoreDisplay = document.getElementById('scoreDisplay');
            const livesDisplay = document.getElementById('livesDisplay');
            const waveDisplay = document.getElementById('waveDisplay');
            const droneLevelDisplay = document.getElementById('droneLevelDisplay');
            const statusMessage = document.getElementById('statusMessage');

            const startButton = document.getElementById('startButton');
            const pauseButton = document.getElementById('pauseButton');
            const messageOverlay = document.getElementById('messageOverlay');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlayText = document.getElementById('overlayText');
            const overlayButton = document.getElementById('overlayButton');
            const upgradeOverlay = document.getElementById('upgradeOverlay');
            const upgradeOptions = document.getElementById('upgradeOptions');
            const upgradeSubtitle = document.getElementById('upgradeSubtitle');
            const skipUpgradeButton = document.getElementById('skipUpgradeButton');

            const state = {
                running: false,
                paused: false,
                lastTime: 0,
                score: 0,
                lives: 3,
                wave: 1,
                spawnTimer: 0,
                spawnInterval: 1.4,
                statusTimer: 0,
                upgrading: false,
                pendingUpgrades: [],
                currentUpgrade: null,
                droneLevelTwoQueued: false
            };

            const controls = {
                left: false,
                right: false,
                up: false,
                down: false,
                shoot: false
            };

            const player = {
                width: 44,
                height: 52,
                speed: 320,
                cooldown: 0.18,
                cooldownTimer: 0,
                x: canvas.width / 2 - 22,
                y: canvas.height - 90
            };

            const bullets = [];
            const enemies = [];
            const powerups = [];
            const drones = [];
            const droneBullets = [];

            const droneWeapon = {
                level: 0,
                maxLevel: 10
            };

            const keyMap = {
                ArrowLeft: 'left',
                ArrowRight: 'right',
                ArrowUp: 'up',
                ArrowDown: 'down',
                KeyA: 'left',
                KeyD: 'right',
                KeyW: 'up',
                KeyS: 'down',
                Space: 'shoot'
            };

            function resetGame() {
                state.running = false;
                state.paused = false;
                state.score = 0;
                state.lives = 3;
                state.wave = 1;
                state.spawnTimer = 0;
                state.spawnInterval = 1.4;
                state.lastTime = 0;
                state.statusTimer = 0;
                bullets.length = 0;
                enemies.length = 0;
                powerups.length = 0;
                drones.length = 0;
                droneBullets.length = 0;
                droneWeapon.level = 0;
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 90;
                player.cooldownTimer = 0;
                state.upgrading = false;
                state.pendingUpgrades.length = 0;
                state.currentUpgrade = null;
                state.droneLevelTwoQueued = false;
                upgradeOverlay.hidden = true;
                updateHUD();
                statusMessage.textContent = '';
                messageOverlay.hidden = true;
                pauseButton.textContent = '暫停';
                pauseButton.setAttribute('aria-pressed', 'false');
            }

            function startGame() {
                resetGame();
                state.running = true;
                requestAnimationFrame(loop);
                announce('祝你好運，飛行員！');
            }

            function togglePause() {
                if (!state.running) {
                    return;
                }

                if (state.upgrading) {
                    return;
                }

                state.paused = !state.paused;
                pauseButton.textContent = state.paused ? '繼續' : '暫停';
                pauseButton.setAttribute('aria-pressed', String(state.paused));
                statusMessage.textContent = state.paused ? '暫停中' : '';
                state.statusTimer = state.paused ? 0 : state.statusTimer;
            }

            function endGame(victory = false) {
                state.running = false;
                messageOverlay.hidden = false;
                overlayTitle.textContent = victory ? '任務完成！' : '遊戲結束';
                overlayText.textContent = `本次得分：${state.score}\n最高波次：${state.wave}`;
                upgradeOverlay.hidden = true;
                state.upgrading = false;
                state.pendingUpgrades.length = 0;
                state.currentUpgrade = null;
                state.droneLevelTwoQueued = false;
            }

            function updateHUD() {
                scoreDisplay.textContent = state.score;
                livesDisplay.textContent = state.lives;
                waveDisplay.textContent = state.wave;
                droneLevelDisplay.textContent = `Lv${droneWeapon.level}`;
            }

            function announce(message, duration = 2.2) {
                statusMessage.innerHTML = `<span>${message}</span>`;
                state.statusTimer = duration;
            }

            function spawnEnemy() {
                const size = 32 + Math.random() * 18;
                const speed = 95 + state.wave * 18 + Math.random() * 35;
                const drift = (Math.random() * 120 - 60) * 0.5;
                enemies.push({
                    x: Math.random() * (canvas.width - size),
                    y: -size,
                    width: size,
                    height: size,
                    speed,
                    drift
                });
            }

            function fireBullet() {
                bullets.push({
                    x: player.x + player.width / 2 - 3,
                    y: player.y - 12,
                    width: 6,
                    height: 18,
                    speed: 520
                });
            }

            function handleInput(dt) {
                const horizontal = (controls.left ? -1 : 0) + (controls.right ? 1 : 0);
                const vertical = (controls.up ? -1 : 0) + (controls.down ? 1 : 0);

                player.x += horizontal * player.speed * dt;
                player.y += vertical * player.speed * dt;

                player.x = Math.max(16, Math.min(canvas.width - player.width - 16, player.x));
                player.y = Math.max(40, Math.min(canvas.height - player.height - 16, player.y));

                player.cooldownTimer = Math.max(0, player.cooldownTimer - dt);
                if (controls.shoot && player.cooldownTimer === 0) {
                    fireBullet();
                    player.cooldownTimer = player.cooldown;
                }
            }

            function updateBullets(dt) {
                for (let i = bullets.length - 1; i >= 0; i -= 1) {
                    const bullet = bullets[i];
                    bullet.y -= bullet.speed * dt;
                    if (bullet.y + bullet.height < 0) {
                        bullets.splice(i, 1);
                    }
                }

                for (let i = droneBullets.length - 1; i >= 0; i -= 1) {
                    const bullet = droneBullets[i];
                    bullet.x += bullet.vx * dt;
                    bullet.y += bullet.vy * dt;

                    if (
                        bullet.x < -40 ||
                        bullet.x > canvas.width + 40 ||
                        bullet.y < -60 ||
                        bullet.y > canvas.height + 60
                    ) {
                        droneBullets.splice(i, 1);
                    }
                }
            }

            function updateEnemies(dt) {
                for (let i = enemies.length - 1; i >= 0; i -= 1) {
                    const enemy = enemies[i];
                    enemy.y += enemy.speed * dt;
                    enemy.x += enemy.drift * dt;

                    if (enemy.x < 8 || enemy.x + enemy.width > canvas.width - 8) {
                        enemy.drift *= -1;
                    }

                    if (enemy.y > canvas.height) {
                        enemies.splice(i, 1);
                        damagePlayer();
                        continue;
                    }

                    if (rectsIntersect(enemy, player)) {
                        enemies.splice(i, 1);
                        damagePlayer();
                        continue;
                    }

                    let removed = false;

                    for (let j = bullets.length - 1; j >= 0; j -= 1) {
                        const bullet = bullets[j];
                        if (rectsIntersect(enemy, bullet)) {
                            enemies.splice(i, 1);
                            bullets.splice(j, 1);
                            state.score += 120;
                            maybeDropPowerup(enemy);
                            updateWave();
                            updateHUD();
                            announce('擊墜敵機 +120 分', 1.2);
                            removed = true;
                            break;
                        }
                    }

                    if (removed) {
                        continue;
                    }

                    for (let j = droneBullets.length - 1; j >= 0; j -= 1) {
                        const bullet = droneBullets[j];
                        if (rectsIntersect(enemy, bullet)) {
                            enemies.splice(i, 1);
                            droneBullets.splice(j, 1);
                            state.score += 150;
                            maybeDropPowerup(enemy);
                            updateWave();
                            updateHUD();
                            announce('無人機殲滅 +150 分', 1.2);
                            removed = true;
                            break;
                        }
                    }

                    if (removed) {
                        continue;
                    }
                }
            }

            function damagePlayer() {
                if (!state.running) {
                    return;
                }

                state.lives -= 1;
                updateHUD();
                announce('受到傷害！剩餘生命：' + state.lives, 1.5);

                if (state.lives <= 0) {
                    endGame(false);
                }
            }

            function updateWave() {
                const nextWave = 1 + Math.floor(state.score / 1600);
                if (nextWave > state.wave) {
                    state.wave = nextWave;
                    state.spawnInterval = Math.max(0.6, 1.4 - (state.wave - 1) * 0.12);
                    announce(`第 ${state.wave} 波來襲！`, 2.4);
                    if (state.wave > 1) {
                        queueUpgrade();
                    }
                }
            }

            function rectsIntersect(a, b) {
                return (
                    a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y
                );
            }

            function maybeDropPowerup(enemy) {
                if (
                    droneWeapon.level >= droneWeapon.maxLevel ||
                    Math.random() > 0.18
                ) {
                    return;
                }

                powerups.push({
                    type: 'drone',
                    x: enemy.x + enemy.width / 2 - 14,
                    y: enemy.y + enemy.height / 2 - 14,
                    width: 28,
                    height: 28,
                    speed: 120
                });
            }

            function upgradeDroneWeapon() {
                if (droneWeapon.level >= droneWeapon.maxLevel) {
                    return;
                }

                droneWeapon.level += 1;
                addDroneUnit();
                updateHUD();

                if (droneWeapon.level === 1 && !state.droneLevelTwoQueued) {
                    state.droneLevelTwoQueued = true;
                    state.pendingUpgrades.push({ type: 'drone', source: 'unlock' });
                }

                if (droneWeapon.level === droneWeapon.maxLevel) {
                    announce('無人機支援已達滿級！', 3);
                } else {
                    announce(`無人機支援等級 ${droneWeapon.level}`, 2.4);
                }

                if (droneWeapon.level >= droneWeapon.maxLevel && state.upgrading) {
                    upgradeSubtitle.textContent = '無人機支援已達上限。';
                }
            }

            function queueUpgrade(source = 'wave') {
                if (droneWeapon.level >= droneWeapon.maxLevel) {
                    return;
                }

                state.pendingUpgrades.push({ type: 'drone', source });
                if (!state.upgrading) {
                    showUpgradeOverlay();
                }
            }

            function showUpgradeOverlay() {
                if (state.upgrading || state.pendingUpgrades.length === 0) {
                    return;
                }

                state.currentUpgrade = state.pendingUpgrades.shift();
                state.upgrading = true;
                state.paused = true;
                pauseButton.textContent = '繼續';
                pauseButton.setAttribute('aria-pressed', 'true');
                statusMessage.innerHTML = '<span>選擇升級</span>';
                upgradeSubtitle.textContent = state.currentUpgrade?.source === 'powerup'
                    ? '你獲得了一個強化核心，選擇要如何使用。'
                    : '選擇一項能力強化。';
                upgradeOverlay.hidden = false;
                renderUpgradeOptions();
            }

            function renderUpgradeOptions() {
                upgradeOptions.textContent = '';

                if (!state.currentUpgrade) {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `
                        <span class="title">暫無可用升級</span>
                        <span class="meta">提示</span>
                        <span class="desc">目前沒有可選擇的升級項目。</span>
                    `;
                    upgradeOptions.append(card);
                    skipUpgradeButton.textContent = '關閉';
                    return;
                }

                if (droneWeapon.level >= droneWeapon.maxLevel) {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.setAttribute('aria-disabled', 'true');
                    card.innerHTML = `
                        <span class="title">無人機支援</span>
                        <span class="meta">MAX</span>
                        <span class="desc">所有無人機已達最高效率。</span>
                    `;
                    upgradeOptions.append(card);
                    skipUpgradeButton.textContent = '確定';
                    return;
                }

                const nextLevel = droneWeapon.level + 1;
                const card = document.createElement('button');
                card.type = 'button';
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <span class="title">無人機支援</span>
                    <span class="meta">Lv ${droneWeapon.level} → Lv ${nextLevel}</span>
                    <span class="desc">召喚並強化環繞無人機，鎖定目標並提供致命火力支援。</span>
                `;
                card.addEventListener('click', () => {
                    upgradeDroneWeapon();
                    completeUpgrade(true);
                });
                upgradeOptions.append(card);
                skipUpgradeButton.textContent = '下次再說';
            }

            function completeUpgrade(applied = false) {
                if (!state.upgrading) {
                    return;
                }

                upgradeOverlay.hidden = true;
                state.upgrading = false;
                state.currentUpgrade = null;
                state.paused = false;
                pauseButton.textContent = '暫停';
                pauseButton.setAttribute('aria-pressed', 'false');

                if (!applied) {
                    announce('已略過升級', 1.6);
                }

                if (state.pendingUpgrades.length > 0) {
                    showUpgradeOverlay();
                }
            }

            function addDroneUnit() {
                const angle = Math.random() * Math.PI * 2;
                drones.push({
                    angle,
                    fireCooldown: 0
                });
            }

            function updatePowerups(dt) {
                for (let i = powerups.length - 1; i >= 0; i -= 1) {
                    const powerup = powerups[i];
                    powerup.y += powerup.speed * dt;

                    if (powerup.y > canvas.height + 40) {
                        powerups.splice(i, 1);
                        continue;
                    }

                    if (rectsIntersect(powerup, player)) {
                        powerups.splice(i, 1);
                        if (powerup.type === 'drone') {
                            queueUpgrade('powerup');
                            if (!state.upgrading) {
                                announce('取得無人機強化核心', 2);
                            }
                        }
                    }
                }
            }

            function updateDrones(dt) {
                if (!drones.length) {
                    return;
                }

                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const orbitRadius = 74 + droneWeapon.level * 3;
                const fireInterval = Math.max(0.3, 1.2 - droneWeapon.level * 0.08);
                const rotationSpeed = 0.9 + Math.min(1.8, droneWeapon.level * 0.12);

                drones.forEach(drone => {
                    drone.angle += rotationSpeed * dt;
                    drone.x = playerCenterX + Math.cos(drone.angle) * orbitRadius;
                    drone.y = playerCenterY + Math.sin(drone.angle) * orbitRadius;
                    drone.fireCooldown = Math.max(0, drone.fireCooldown - dt);

                    if (enemies.length === 0 || drone.fireCooldown > 0) {
                        return;
                    }

                    const target = findNearestEnemy(drone.x, drone.y);
                    if (!target) {
                        return;
                    }

                    fireDroneBullet(drone.x, drone.y, target);
                    drone.fireCooldown = fireInterval;
                });
            }

            function findNearestEnemy(x, y) {
                let nearest = null;
                let nearestDistSq = Infinity;
                enemies.forEach(enemy => {
                    const cx = enemy.x + enemy.width / 2;
                    const cy = enemy.y + enemy.height / 2;
                    const dx = cx - x;
                    const dy = cy - y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < nearestDistSq) {
                        nearest = enemy;
                        nearestDistSq = distSq;
                    }
                });
                return nearest;
            }

            function fireDroneBullet(x, y, target) {
                const cx = target.x + target.width / 2;
                const cy = target.y + target.height / 2;
                const dx = cx - x;
                const dy = cy - y;
                const length = Math.max(Math.hypot(dx, dy), 1);
                const speed = 620;

                droneBullets.push({
                    x: x - 4,
                    y: y - 4,
                    width: 8,
                    height: 8,
                    vx: (dx / length) * speed,
                    vy: (dy / length) * speed
                });
            }

            function update(dt) {
                handleInput(dt);
                updateDrones(dt);
                updateBullets(dt);
                updatePowerups(dt);
                updateEnemies(dt);

                state.spawnTimer += dt;
                if (state.spawnTimer >= state.spawnInterval) {
                    state.spawnTimer = 0;
                    spawnEnemy();
                }

                if (state.statusTimer > 0 && !state.paused) {
                    state.statusTimer -= dt;
                    if (state.statusTimer <= 0) {
                        statusMessage.textContent = '';
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0b1220');
                gradient.addColorStop(0.5, '#0f172a');
                gradient.addColorStop(1, '#020617');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'rgba(148, 163, 184, 0.15)';
                for (let i = 0; i < 60; i += 1) {
                    const x = (i * 137 + performance.now() * 0.02) % canvas.width;
                    const y = (i * 53 + performance.now() * 0.04) % canvas.height;
                    ctx.fillRect(x, y, 2, 2);
                }

                ctx.fillStyle = '#38bdf8';
                ctx.beginPath();
                ctx.moveTo(player.x + player.width / 2, player.y);
                ctx.lineTo(player.x + player.width, player.y + player.height - 8);
                ctx.lineTo(player.x + player.width / 2, player.y + player.height);
                ctx.lineTo(player.x, player.y + player.height - 8);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#0ea5e9';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#f8fafc';
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });

                droneBullets.forEach(bullet => {
                    const gradient = ctx.createRadialGradient(
                        bullet.x + bullet.width / 2,
                        bullet.y + bullet.height / 2,
                        0,
                        bullet.x + bullet.width / 2,
                        bullet.y + bullet.height / 2,
                        12
                    );
                    gradient.addColorStop(0, '#f472b6');
                    gradient.addColorStop(1, 'rgba(244, 114, 182, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });

                powerups.forEach(powerup => {
                    const gradient = ctx.createLinearGradient(powerup.x, powerup.y, powerup.x, powerup.y + powerup.height);
                    gradient.addColorStop(0, '#22d3ee');
                    gradient.addColorStop(1, '#0ea5e9');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(powerup.x, powerup.y, powerup.width, powerup.height);
                    ctx.strokeStyle = 'rgba(15, 23, 42, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(powerup.x, powerup.y, powerup.width, powerup.height);
                    ctx.fillStyle = '#020617';
                    ctx.font = 'bold 16px "Segoe UI"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('D', powerup.x + powerup.width / 2, powerup.y + powerup.height / 2 + 1);
                });

                drones.forEach(drone => {
                    if (typeof drone.x === 'undefined' || typeof drone.y === 'undefined') {
                        return;
                    }
                    ctx.save();
                    ctx.translate(drone.x, drone.y);
                    ctx.rotate(drone.angle);
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(10, 12);
                    ctx.lineTo(-10, 12);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                });

                enemies.forEach(enemy => {
                    const enemyGradient = ctx.createLinearGradient(enemy.x, enemy.y, enemy.x, enemy.y + enemy.height);
                    enemyGradient.addColorStop(0, '#f97316');
                    enemyGradient.addColorStop(1, '#ef4444');
                    ctx.fillStyle = enemyGradient;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    ctx.strokeStyle = 'rgba(15, 23, 42, 0.8)';
                    ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
                });
            }

            function loop(timestamp) {
                if (!state.running) {
                    return;
                }

                if (!state.lastTime) {
                    state.lastTime = timestamp;
                }

                const delta = Math.min((timestamp - state.lastTime) / 1000, 0.05);
                state.lastTime = timestamp;

                if (!state.paused) {
                    update(delta);
                    draw();
                }

                requestAnimationFrame(loop);
            }

            startButton.addEventListener('click', startGame);
            pauseButton.addEventListener('click', togglePause);
            overlayButton.addEventListener('click', startGame);
            skipUpgradeButton.addEventListener('click', () => completeUpgrade(false));

            document.addEventListener('visibilitychange', () => {
                if (document.hidden && state.running && !state.paused) {
                    togglePause();
                }
            });

            window.addEventListener('keydown', event => {
                const control = keyMap[event.code];
                if (control) {
                    event.preventDefault();
                    controls[control] = true;
                }
            });

            window.addEventListener('keyup', event => {
                const control = keyMap[event.code];
                if (control) {
                    controls[control] = false;
                }
            });

            updateHUD();
        })();
    </script>
</body>
</html>

